// DSL Persistence Layer with Validation
// Ensures all DSL documents are validated before persisting to database

import { z } from 'zod'
import type { Prisma, PrismaClient } from '@prisma/client'
import { prisma } from './client'
import { revisionRepository, screenRepository, type RepositoryLogger } from './repositories'
import { validateScreenDSL, validateFlowDSL, assertScreenDSL, assertFlowDSL, ValidationError } from '../dsl/validator'
import { validateDSLAgainstPattern, validateDSLWithPattern } from '../patterns/validator'
import { loadPattern } from '../patterns/loader'
import type { ScreenDSL, FlowDSL } from '../dsl/types'
import type { PatternDefinition } from '../patterns/schema'

export interface PersistenceResult<T> {
  success: boolean
  data?: T
  error?: string
  validationErrors?: string[]
}

type DbClient = PrismaClient | Prisma.TransactionClient

/**
 * Validate DSL before persistence
 * Performs both schema validation and pattern validation
 */
export async function validateDSLForPersistence(
  dsl: unknown,
  requirePatternValidation: boolean = true
): Promise<{ success: boolean; dsl?: ScreenDSL; errors?: string[] }> {
  // Step 1: Schema validation
  const schemaResult = validateScreenDSL(dsl)
  if (!schemaResult.success) {
    return {
      success: false,
      errors: schemaResult.formattedErrors || [schemaResult.error?.message || 'Schema validation failed'],
    }
  }

  const validatedDSL = schemaResult.data!

  // Step 2: Pattern validation (if required)
  if (requirePatternValidation) {
    try {
      const pattern = loadPattern(validatedDSL.pattern_family, validatedDSL.pattern_variant)
      const patternResult = validateDSLAgainstPattern(validatedDSL, pattern)

      if (!patternResult.valid) {
        return {
          success: false,
          errors: patternResult.errors.map((err) => `${err.field}: ${err.message}`),
        }
      }
    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : 'Failed to load pattern for validation'],
      }
    }
  }

  return {
    success: true,
    dsl: validatedDSL,
  }
}

/**
 * Create a revision with validation
 * Throws ValidationError if DSL is invalid
 * @deprecated Use createRevision from lib/revisions/revision-service.ts for full metadata support
 */
export async function createRevisionWithValidation(
  flowId: string,
  dsl: unknown,
  options: {
    screenId?: string
    version?: number
    changeType?: string
    skipPatternValidation?: boolean
    userId?: string
    description?: string
    parentRevisionId?: string
    isAutoGenerated?: boolean
    client?: DbClient
    logger?: RepositoryLogger
  } = {}
): Promise<{ revision: any; dsl: ScreenDSL }> {
  // Validate DSL
  const validation = await validateDSLForPersistence(dsl, !options.skipPatternValidation)

  if (!validation.success || !validation.dsl) {
    // Create a ZodError from validation errors for proper error handling
    const zodError = new z.ZodError(
      validation.errors?.map((msg) => ({
        code: 'custom',
        path: [],
        message: msg,
      })) || []
    )
    throw new ValidationError('DSL validation failed', zodError)
  }

  const validatedDSL = validation.dsl

  // Get latest version for this flow
  const latestRevision = await revisionRepository.getLatestVersion(flowId, {
    tx: options.client,
    logger: options.logger,
  })

  const nextVersion = options.version ?? (latestRevision ? latestRevision.version + 1 : 1)

  // Extract metadata for comprehensive revision storage
  const assetReferences = {
    heroImageId: validatedDSL.hero_image?.id,
    supportingImageIds: validatedDSL.supporting_images?.map((img) => img.id) || [],
  }

  const patternMapping = {
    family: validatedDSL.pattern_family,
    variant: validatedDSL.pattern_variant,
  }

  const screenState = {
    palette: validatedDSL.palette,
    vibe: validatedDSL.vibe,
  }

  // Create revision with all metadata
  const revision = await revisionRepository.create(
    {
      flowId,
      screenId: options.screenId ?? null,
      userId: options.userId ?? null,
      dslSnapshot: JSON.stringify(validatedDSL),
      version: nextVersion,
      changeType: options.changeType ?? 'generation',
      description: options.description ?? null,
      assetReferences: JSON.stringify(assetReferences),
      patternMapping: JSON.stringify(patternMapping),
      screenState: JSON.stringify(screenState),
      parentRevisionId: options.parentRevisionId ?? null,
      isAutoGenerated: options.isAutoGenerated ?? false,
    },
    { tx: options.client, logger: options.logger }
  )

  return { revision, dsl: validatedDSL }
}

/**
 * Create a screen with validation
 * Throws ValidationError if DSL is invalid
 */
export async function createScreenWithValidation(
  flowId: string,
  dsl: unknown,
  options: {
    heroImageId?: string
    skipPatternValidation?: boolean
    client?: DbClient
    logger?: RepositoryLogger
  } = {}
): Promise<{ screen: any; dsl: ScreenDSL }> {
  // Validate DSL
  const validation = await validateDSLForPersistence(dsl, !options.skipPatternValidation)

  if (!validation.success || !validation.dsl) {
    // Create a ZodError from validation errors for proper error handling
    const zodError = new z.ZodError(
      validation.errors?.map((msg) => ({
        code: 'custom',
        path: [],
        message: msg,
      })) || []
    )
    throw new ValidationError('DSL validation failed', zodError)
  }

  const validatedDSL = validation.dsl

  // Create screen
  const screen = await screenRepository.create(
    {
      flowId,
      heroImageId: options.heroImageId ?? null,
      palette: JSON.stringify(validatedDSL.palette),
      vibe: validatedDSL.vibe,
      patternFamily: validatedDSL.pattern_family,
      patternVariant: validatedDSL.pattern_variant,
      components: JSON.stringify(validatedDSL.components),
      navigation: validatedDSL.navigation ? JSON.stringify(validatedDSL.navigation) : null,
      animations: validatedDSL.animations ? JSON.stringify(validatedDSL.animations) : null,
      metadata: validatedDSL.metadata ? JSON.stringify(validatedDSL.metadata) : null,
    },
    { tx: options.client, logger: options.logger }
  )

  // Create revision for new screen generation
  await createRevisionWithValidation(flowId, validatedDSL, {
    screenId: screen.id,
    changeType: 'generation',
    isAutoGenerated: true,
    skipPatternValidation: options.skipPatternValidation,
    client: options.client,
    logger: options.logger,
  })

  return { screen, dsl: validatedDSL }
}

/**
 * Update a screen with validation
 * Accepts partial DSL updates and merges with existing screen data
 * Throws ValidationError if DSL is invalid
 */
export async function updateScreenWithValidation(
  screenId: string,
  dslUpdate: Partial<ScreenDSL>,
  options: {
    skipPatternValidation?: boolean
    changeType?: string
    client?: DbClient
    logger?: RepositoryLogger
  } = {}
): Promise<{ screen: any; dsl: ScreenDSL }> {
  // Get existing screen
  const existingScreen = await screenRepository.findById(screenId, {
    includeHero: true,
    tx: options.client,
    logger: options.logger,
  })

  if (!existingScreen) {
    throw new Error(`Screen not found: ${screenId}`)
  }

  // Reconstruct existing DSL from database
  const existingDSL: ScreenDSL = {
    hero_image: existingScreen.heroImage
      ? {
          id: existingScreen.heroImage.id,
          url: existingScreen.heroImage.url,
          prompt: existingScreen.heroImage.prompt || undefined,
          seed: existingScreen.heroImage.seed || undefined,
          aspectRatio: existingScreen.heroImage.aspectRatio || undefined,
          style: existingScreen.heroImage.style || undefined,
          extractedPalette: existingScreen.heroImage.extractedPalette
            ? (JSON.parse(existingScreen.heroImage.extractedPalette as string) as ScreenDSL['palette'])
            : undefined,
          vibe: (existingScreen.heroImage.vibe as ScreenDSL['vibe']) || undefined,
        }
      : {
          id: 'placeholder',
          url: '',
        },
    palette: existingScreen.palette
      ? (JSON.parse(existingScreen.palette as string) as ScreenDSL['palette'])
      : {
          primary: '#000000',
          secondary: '#666666',
          accent: '#0066ff',
          background: '#ffffff',
        },
    vibe: (existingScreen.vibe as ScreenDSL['vibe']) || 'modern',
    pattern_family: (existingScreen.patternFamily as ScreenDSL['pattern_family']) || 'ONB_HERO_TOP',
    pattern_variant: (existingScreen.patternVariant as ScreenDSL['pattern_variant']) || 1,
    components: existingScreen.components
      ? (JSON.parse(existingScreen.components as string) as ScreenDSL['components'])
      : [],
    navigation: existingScreen.navigation
      ? (JSON.parse(existingScreen.navigation as string) as ScreenDSL['navigation'])
      : undefined,
    animations: existingScreen.animations
      ? (JSON.parse(existingScreen.animations as string) as ScreenDSL['animations'])
      : undefined,
    metadata: existingScreen.metadata
      ? (JSON.parse(existingScreen.metadata as string) as ScreenDSL['metadata'])
      : undefined,
  }

  // Merge updates into existing DSL
  const mergedDSL: ScreenDSL = {
    ...existingDSL,
    ...dslUpdate,
    // Deep merge nested objects
    palette: dslUpdate.palette || existingDSL.palette,
    hero_image: dslUpdate.hero_image || existingDSL.hero_image,
    components: dslUpdate.components || existingDSL.components,
  }

  // Validate merged DSL
  const validation = await validateDSLForPersistence(mergedDSL, !options.skipPatternValidation)

  if (!validation.success || !validation.dsl) {
    const zodError = new z.ZodError(
      validation.errors?.map((msg) => ({
        code: 'custom',
        path: [],
        message: msg,
      })) || []
    )
    throw new ValidationError('DSL validation failed', zodError)
  }

  const validatedDSL = validation.dsl

  // Create revision for history tracking with full metadata
  await createRevisionWithValidation(existingScreen.flowId, validatedDSL, {
    screenId,
    changeType: options.changeType || 'edit',
    skipPatternValidation: options.skipPatternValidation,
    isAutoGenerated: false, // Manual edits are not auto-generated
    client: options.client,
    logger: options.logger,
  })

  // Update screen
  const updatedScreen = await screenRepository.update(
    screenId,
    {
      heroImage:
        validatedDSL.hero_image.id !== existingDSL.hero_image.id
          ? { connect: { id: validatedDSL.hero_image.id } }
          : undefined,
      palette: JSON.stringify(validatedDSL.palette),
      vibe: validatedDSL.vibe,
      patternFamily: validatedDSL.pattern_family,
      patternVariant: validatedDSL.pattern_variant,
      components: JSON.stringify(validatedDSL.components),
      navigation: validatedDSL.navigation ? JSON.stringify(validatedDSL.navigation) : null,
      animations: validatedDSL.animations ? JSON.stringify(validatedDSL.animations) : null,
      metadata: validatedDSL.metadata ? JSON.stringify(validatedDSL.metadata) : null,
    },
    { tx: options.client, logger: options.logger, includeHero: true }
  )

  return { screen: updatedScreen, dsl: validatedDSL }
}

/**
 * Validate FlowDSL before persistence
 */
export function validateFlowForPersistence(
  flow: unknown
): PersistenceResult<FlowDSL> {
  const result = validateFlowDSL(flow)

  if (!result.success) {
    return {
      success: false,
      error: result.error?.message || 'FlowDSL validation failed',
      validationErrors: result.formattedErrors,
    }
  }

  return {
    success: true,
    data: result.data,
  }
}

