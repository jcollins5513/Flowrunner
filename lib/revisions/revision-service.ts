// Revision Service
// Comprehensive revision tracking with full metadata storage

import { prisma } from '../db/client'
import type { ScreenDSL } from '../dsl/types'
import { validateScreenDSL } from '../dsl/validator'

/**
 * Asset references stored in revision
 */
export interface AssetReferences {
  heroImageId?: string
  supportingImageIds?: string[]
}

/**
 * Pattern mapping stored in revision
 */
export interface PatternMapping {
  family: string
  variant: number
}

/**
 * Screen state stored in revision
 */
export interface ScreenState {
  palette?: {
    primary: string
    secondary: string
    accent: string
    background: string
  }
  vibe?: string
}

/**
 * Revision creation options
 */
export interface CreateRevisionOptions {
  screenId?: string
  userId?: string
  version?: number
  changeType?: 'generation' | 'edit' | 'restore' | 'merge' | 'branch' | 'manual'
  description?: string
  parentRevisionId?: string
  isAutoGenerated?: boolean
  skipPatternValidation?: boolean
}

/**
 * Create a comprehensive revision with all metadata
 */
export async function createRevision(
  flowId: string,
  dsl: ScreenDSL,
  options: CreateRevisionOptions = {}
): Promise<{ revision: any; dsl: ScreenDSL }> {
  // Validate DSL
  const validation = validateScreenDSL(dsl)
  if (!validation.success || !validation.data) {
    throw new Error(
      `DSL validation failed: ${validation.error?.message || 'Unknown error'}`
    )
  }

  const validatedDSL = validation.data

  // Get latest version for this flow
  const latestRevision = await prisma.revision.findFirst({
    where: { flowId },
    orderBy: { version: 'desc' },
  })

  const nextVersion = options.version ?? (latestRevision ? latestRevision.version + 1 : 1)

  // Extract asset references
  const assetReferences: AssetReferences = {
    heroImageId: validatedDSL.hero_image?.id,
    supportingImageIds: validatedDSL.supporting_images?.map((img) => img.id) || [],
  }

  // Extract pattern mapping
  const patternMapping: PatternMapping = {
    family: validatedDSL.pattern_family,
    variant: validatedDSL.pattern_variant,
  }

  // Extract screen state
  const screenState: ScreenState = {
    palette: validatedDSL.palette,
    vibe: validatedDSL.vibe,
  }

  // Create revision with all metadata
  const revision = await prisma.revision.create({
    data: {
      flowId,
      screenId: options.screenId ?? null,
      userId: options.userId ?? null,
      dslSnapshot: JSON.stringify(validatedDSL),
      version: nextVersion,
      changeType: options.changeType ?? 'generation',
      description: options.description ?? null,
      assetReferences: JSON.stringify(assetReferences),
      patternMapping: JSON.stringify(patternMapping),
      screenState: JSON.stringify(screenState),
      parentRevisionId: options.parentRevisionId ?? null,
      isAutoGenerated: options.isAutoGenerated ?? false,
    },
  })

  return { revision, dsl: validatedDSL }
}

/**
 * Get revision by ID
 */
export async function getRevision(revisionId: string) {
  return prisma.revision.findUnique({
    where: { id: revisionId },
    include: {
      user: true,
      screen: true,
      flow: true,
      parentRevision: true,
    },
  })
}

/**
 * Get all revisions for a flow
 */
export async function getFlowRevisions(
  flowId: string,
  options: {
    screenId?: string
    changeType?: string
    limit?: number
    offset?: number
  } = {}
) {
  const where: any = { flowId }
  if (options.screenId) where.screenId = options.screenId
  if (options.changeType) where.changeType = options.changeType

  return prisma.revision.findMany({
    where,
    orderBy: { version: 'desc' },
    take: options.limit,
    skip: options.offset,
    include: {
      user: true,
      screen: true,
    },
  })
}

/**
 * Get latest revision for a flow
 */
export async function getLatestRevision(flowId: string, screenId?: string) {
  const where: any = { flowId }
  if (screenId) where.screenId = screenId

  return prisma.revision.findFirst({
    where,
    orderBy: { version: 'desc' },
    include: {
      user: true,
      screen: true,
    },
  })
}

/**
 * Get revision count for a flow
 */
export async function getRevisionCount(flowId: string, screenId?: string): Promise<number> {
  const where: any = { flowId }
  if (screenId) where.screenId = screenId

  return prisma.revision.count({ where })
}

/**
 * Restore a revision (create a new revision from an old one)
 */
export async function restoreRevision(
  revisionId: string,
  options: {
    userId?: string
    description?: string
  } = {}
) {
  const sourceRevision = await getRevision(revisionId)
  if (!sourceRevision) {
    throw new Error(`Revision not found: ${revisionId}`)
  }

  const dsl: ScreenDSL = JSON.parse(sourceRevision.dslSnapshot)

  return createRevision(sourceRevision.flowId, dsl, {
    screenId: sourceRevision.screenId ?? undefined,
    userId: options.userId,
    changeType: 'restore',
    description: options.description || `Restored from revision ${sourceRevision.version}`,
    parentRevisionId: revisionId,
  })
}

/**
 * Get revision diff (compare two revisions)
 */
export async function getRevisionDiff(revisionId1: string, revisionId2: string) {
  const rev1 = await getRevision(revisionId1)
  const rev2 = await getRevision(revisionId2)

  if (!rev1 || !rev2) {
    throw new Error('One or both revisions not found')
  }

  const dsl1: ScreenDSL = JSON.parse(rev1.dslSnapshot)
  const dsl2: ScreenDSL = JSON.parse(rev2.dslSnapshot)

  // Simple diff - in production, use a proper diff library
  const changes: string[] = []

  if (dsl1.pattern_family !== dsl2.pattern_family) {
    changes.push(`Pattern family: ${dsl1.pattern_family} → ${dsl2.pattern_family}`)
  }
  if (dsl1.pattern_variant !== dsl2.pattern_variant) {
    changes.push(`Pattern variant: ${dsl1.pattern_variant} → ${dsl2.pattern_variant}`)
  }
  if (dsl1.vibe !== dsl2.vibe) {
    changes.push(`Vibe: ${dsl1.vibe} → ${dsl2.vibe}`)
  }
  if (JSON.stringify(dsl1.palette) !== JSON.stringify(dsl2.palette)) {
    changes.push('Palette changed')
  }
  if (dsl1.components.length !== dsl2.components.length) {
    changes.push(`Components: ${dsl1.components.length} → ${dsl2.components.length}`)
  }
  if (dsl1.hero_image?.id !== dsl2.hero_image?.id) {
    changes.push('Hero image changed')
  }

  return {
    revision1: rev1,
    revision2: rev2,
    changes,
  }
}

